# Appendix: Solving the coding interview

Those fancy "coding interviews" are definitely about coding, but they key is _framing the problem they give you in a way that can be coded_. That usually means an algorithm. And **the key to developing an algorithm to solve a problem is thoroughly understanding the problem**.

Focus on formulating a solution, in words to the problem. Then take those words, take what you learned in this book,
and translate that shit into an algorithm. _Then_ worry about the run-time and space complexity. At the very worst,
this will show them that you are skilled at idea comprehension, and will be enough signal to paint a picture in their
head as to what you would do. As long as you write _some_ code, that provides good signal. (BIBLIO: CRACKING THE CODING INTERVIEW) [provide the reference].

---

## OLD NOTION DRAFT

The FAANG interviews are expecting you to know, very well, the basic building blocks of computer science.

What they do is disguise these building blocks in the form of real-world scenarios, and expect you to discover the hidden building blocks behind these real-world scenarios. This is the heart of computer programming…to understand the models and operations that map our world into that of a computer.

You must understand two things really well:

## The fundamentals

- Every data structure, algorithm, etc, you must know it cold. That is the most important thing. You must study it thoroughly, understand how it works, what it looks like, and what it can be used for.

## Pattern matching

- You must take real-world scenarios, and map them to the fundamental data structures and algorithms.

## How problem difficulty is established

Problem difficulty seems to be dependent on two primary factors:

- The number of different fundamentals the problem contains, or **breadth**
- The amount of digging you have to do in order to uncover the fundamental and fit all of the pieces together, or **depth**

## How to go about solving them

Yes, ask the clarifying questions and write the test phases and communicate your thought processes, solve it naively, etc. here’s how you could think about it:

1. Ensure that you fully understand the structure and the properties / examples of the problem
2. Pattern match the structure and properties to the fundamentals, and then deploy those fundamentals.

So here’s what you do:

## Study the fundamentals

Like, really study them. Study the shit out of them. Study everything about them.

## Practice Pattern-Matching

Do as many problem-solving interviews as possible, and try to match them to the fundamentals.

## Why this is actually a valid approach

When you code, you need to look at real-world problems, and match them to domain knowledge. That could be react, that could be databases, that could be anything. But in order to code really well, you need to understand the tools, and you need to be able to deploy the tools where necessary. The fundamentals are the lowest common denominator, and although you don’t use them all the time, the one constant in tech is change and you must be able to learn and adapt very quickly. So focus primarily on **learning the fundamentals**, and then practice **applying the fundamentals**.
